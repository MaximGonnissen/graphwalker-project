package org.graphwalker.core.utils;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.graphwalker.core.model.Edge;
import org.graphwalker.core.model.Model;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * <h1>BenchmarkPathParser</h1>
 * <p>Parser for paths generated by the Benchmark command, for use in PredefinedPath execution.</p>
 */
public class BenchmarkPathParser {

  /**
   * <p> Verify that the path contains a valid Benchmark structure, meaning the runs directory is present and non-empty.</p>
   */
  public static boolean isValidBenchmarkPath(String path) {
    Path benchmarkPath = Paths.get(path);
    if (!benchmarkPath.toFile().exists()) {
      return false;
    }
    if (!benchmarkPath.toFile().isDirectory()) {
      return false;
    }
    Objects.requireNonNull(benchmarkPath.toFile().listFiles());

    for (File runDir : Objects.requireNonNull(benchmarkPath.toFile().listFiles())) {
      if (!runDir.isDirectory()) {
        continue;
      }
      if (runDir.getName().equalsIgnoreCase("runs")) {
        return Objects.requireNonNull(runDir.listFiles()).length != 0;
      }
    }
    return false;
  }

  public static boolean isRunPathFile(File file) {
    return file.getName().endsWith("_path.json");
  }

  private static File getRunsDirectory(String path) {
    Path benchmarkPath = Paths.get(path);
    for (File runDir : Objects.requireNonNull(benchmarkPath.toFile().listFiles())) {
      if (!runDir.isDirectory()) {
        continue;
      }
      if (runDir.getName().equalsIgnoreCase("runs")) {
        return runDir;
      }
    }
    return null;
  }

  public static BenchmarkPath parseRunFile(Model model, File runFile, File runDir) {
    List<Edge> path = new ArrayList<>();

    String fileContent;
    try {
      fileContent = Files.readString(runFile.toPath());
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    JsonArray jsonArray = new Gson().fromJson(fileContent, JsonArray.class).getAsJsonArray();

    for (JsonElement jsonElement : jsonArray) {
      JsonObject jsonObject = jsonElement.getAsJsonObject();
      String elementId = jsonObject.get("elementId").getAsString();
      for (Edge edge : model.getEdges()) {
        if (edge.getId().equals(elementId)) {
          path.add(edge);
          break;
        }
      }
    }

    Integer runId = Integer.valueOf(runFile.getName().split("_")[1]);

    return new BenchmarkPath(runDir.getName(), runId, path);
  }

  private static List<BenchmarkPath> parseRunsSubdirectory(Model model, File runDir) {
    return parseRunsSubdirectory(model, runDir, Integer.MAX_VALUE);
  }

  private static List<BenchmarkPath> parseRunsSubdirectory(Model model, File runDir, int runLimit) {
    List<BenchmarkPath> benchmarkPaths = new ArrayList<>();

    int runCount = 0;
    for (File runFile : Objects.requireNonNull(runDir.listFiles())) {
      if (!isRunPathFile(runFile)) {
        continue;
      }
      BenchmarkPath benchmarkPath = parseRunFile(model, runFile, runDir);
      benchmarkPaths.add(benchmarkPath);

      if (++runCount >= runLimit) {
        break;
      }
    }

    return benchmarkPaths;
  }

  private static List<BenchmarkPath> parseRunsDirectory(Model model, File runDir) {
    return parseRunsDirectory(model, runDir, Integer.MAX_VALUE);
  }

  private static List<BenchmarkPath> parseRunsDirectory(Model model, File runDir, int runLimit) {
    List<BenchmarkPath> benchmarkPaths = new ArrayList<>();

    for (File runSubDir : Objects.requireNonNull(runDir.listFiles())) {
      if (!runSubDir.isDirectory()) {
        continue;
      }
      List<BenchmarkPath> newBenchmarkPaths = parseRunsSubdirectory(model, runSubDir, runLimit);
      benchmarkPaths.addAll(newBenchmarkPaths);
    }

    return benchmarkPaths;
  }

  public static List<BenchmarkPath> getBenchmarkPaths(Model model, String path) {
    return getBenchmarkPaths(model, path, Integer.MAX_VALUE);
  }

  /**
   * <p>Get a list of BenchmarkPaths from a Benchmark directory.</p>
   * <p>Only the first runLimit runs per run directory are included.</p>
   */
  public static List<BenchmarkPath> getBenchmarkPaths(Model model, String path, int runLimit) {
    if (!isValidBenchmarkPath(path)) {
      throw new IllegalArgumentException("Path is not a valid Benchmark path.");
    }
    return parseRunsDirectory(model, Objects.requireNonNull(getRunsDirectory(path)), runLimit);
  }

  public static List<LateInitBenchmarkPath> getLateInitBenchmarkPaths(String path) {
    return getLateInitBenchmarkPaths(path, Integer.MAX_VALUE);
  }

  /**
   * <p>Get a list of LateInitBenchmarkPaths from a Benchmark directory.</p>
   * <p>Only the first runLimit runs per run directory are included.</p>
   */
  public static List<LateInitBenchmarkPath> getLateInitBenchmarkPaths(String path, int runLimit) {
    if (!isValidBenchmarkPath(path)) {
      throw new IllegalArgumentException("Path is not a valid Benchmark path.");
    }
    List<LateInitBenchmarkPath> lateInitBenchmarkPaths = new ArrayList<>();
    File runsDirectory = getRunsDirectory(path);
    for (File runSubDir : Objects.requireNonNull(runsDirectory.listFiles())) {
      if (!runSubDir.isDirectory()) {
        continue;
      }
      int runCount = 0;
      for (File runFile : Objects.requireNonNull(runSubDir.listFiles())) {
        if (!isRunPathFile(runFile)) {
          continue;
        }
        lateInitBenchmarkPaths.add(new LateInitBenchmarkPath(runFile, runSubDir));
        if (++runCount >= runLimit) {
          break;
        }
      }
    }
    return lateInitBenchmarkPaths;
  }
}
